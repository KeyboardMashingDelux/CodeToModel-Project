using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NMF.Models.Meta;
using NMF.Models.Repository;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Security.Claims;
using System.Xml.Linq;

namespace CTMGenerator {
    [Generator]
    public class ModelGenerator : IIncrementalGenerator {


        private const string AttributesLibName = "CTMLib";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            var modelParts = context.SyntaxProvider.CreateSyntaxProvider(IsModelPart, GetModelParts).Where(type => type is not null).Collect();

            context.RegisterSourceOutput(modelParts, action: GenerateModel);
        }

        private static bool IsModelPart(SyntaxNode syntaxNode, CancellationToken cancellationToken) {
            if (syntaxNode is not AttributeSyntax attribute)
                return false;

            var name = ExtractName(attribute.Name);

            if (name != GeneratorResources.ModelInterafaceAttributeName)
                return false;

            //Debugger.Launch();
            Debug.WriteLine($"### {name} ###");


            return attribute.Parent?.Parent is InterfaceDeclarationSyntax;
        }

        /// <summary>
        /// Tries to extracts the name from a NameSyntax node.
        /// </summary>
        private static string? ExtractName(NameSyntax? name) {
            return name switch {
                SimpleNameSyntax ins => ins.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                AliasQualifiedNameSyntax aqns => aqns.Name.Identifier.Text,
                _ => name?.ToString()
            };
        }

        private static ITypeSymbol? GetModelParts(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // "attribute.Parent" is "AttributeListSyntax"
            // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
            if (attributeSyntax.Parent?.Parent is not InterfaceDeclarationSyntax interfaceDeclaration)
                return null;

            // This is now the actual Symbol and not the node (as seen in the Syntax Visualiser)
            var type = context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) as ITypeSymbol;

            Debug.WriteLine($"+++ {type} +++");
            Trace.WriteLine("################################");

            return type is null || !IsFromCorrectLib(type) ? null : type;
        }

        private static bool IsFromCorrectLib(ISymbol type) {
            foreach (var element in type.GetAttributes())
                Debug.WriteLine($"??? {element} <-> {element.AttributeClass?.Name} <-> {element.AttributeClass?.ContainingNamespace} ???");

            return type.GetAttributes()
                       .Any(a => a.AttributeClass?.Name == GeneratorResources.ModelInterafaceAttributeName &&
                                 a.AttributeClass.ContainingNamespace is {
                                     Name: AttributesLibName,
                                     ContainingNamespace.IsGlobalNamespace: true
                                 }
                       );
        }

        private static void GenerateModel(SourceProductionContext context, ImmutableArray<ITypeSymbol?> elements) {
            if (elements.IsDefaultOrEmpty)
                return;

            Debug.WriteLine($"=== {elements} ===");

            foreach (var element in elements) {
                if (element == null)
                    continue;

                var ns = element.ContainingNamespace.IsGlobalNamespace
                          ? null
                          : element.ContainingNamespace.ToString();
                var name = element.Name;

                var code = @$"// <auto-generated />

{(ns is null ? null : $@"namespace {ns} {{")}
   public partial class {name.Substring(1)} : {name} {{
      }}
   }}
{(ns is null ? null : @"}
")}";
                ;

                context.AddSource($"{(ns is null ? null : ns + ".")}{name}.g.cs", code);
            }

            CreateModel(elements);
        }

        private static void CreateModel(ImmutableArray<ITypeSymbol?> elements) {
            if (!elements.IsDefaultOrEmpty)
                return;

            var repository = new ModelRepository();
            var ns = new Namespace();
            ns.Name = "GENERATED";
            foreach (var element in elements) {
                if (element == null)
                    continue;

                var elementClass = new Class();
                elementClass.Name = element.Name;
                ns.Types.Add(elementClass);
            }

            repository.Save(ns, $"GENERATED.nmeta");
        }
    }
}