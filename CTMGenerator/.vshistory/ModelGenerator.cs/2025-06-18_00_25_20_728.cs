using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using NMF.Expressions.Linq;
using NMF.Models.Meta;
using NMF.Models.Repository;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Xml.Linq;

namespace CTMGenerator {
    [Generator]
    public class ModelGenerator : IIncrementalGenerator {

        private const string AttributesLibName = "CTMLib";

        public void Initialize(IncrementalGeneratorInitializationContext context) {
            //Debugger.Launch();

            // Möglich Werte aus AdditionalFiles zu erhalten -> Anstatt einzelner RegisterSourceOutput einfach per Combine mit modelParts kombinieren
            // 
            //var pro = context.AnalyzerConfigOptionsProvider.Select((provider, ct) => 
            //        provider.GlobalOptions.TryGetValue("build_property.CompilerGeneratedFilesOutputPath", out var compilerGeneratedFilesOutputPath)
            //        ? compilerGeneratedFilesOutputPath : "NOPE");
            //context.RegisterSourceOutput(pro, (ctx, value) =>
            //{
            //    Debug.WriteLine("#####------##########" + value);
            //});

            //Debug.WriteLine("#####------##########" + CompilerGeneratedFilesOutputPath);

            var modelParts = context.SyntaxProvider.CreateSyntaxProvider(IsModelPart, GetModelParts).Where(type => type is not null).Collect();

            var assemblySymbol = context.CompilationProvider.Select((compilation, ct) => compilation.Assembly);

            var fullProvider = modelParts.Combine(assemblySymbol);
            context.RegisterSourceOutput(fullProvider, action: GenerateModel);
        }

        private static bool IsModelPart(SyntaxNode syntaxNode, CancellationToken cancellationToken) {
            if (syntaxNode is not AttributeSyntax attribute)
                return false;

            var name = ExtractName(attribute.Name);

            if (name != GeneratorResources.ModelInterafaceAttributeName)
                return false;

            //Debugger.Launch();
            Debug.WriteLine($"### {name} ###");


            return attribute.Parent?.Parent is InterfaceDeclarationSyntax;
        }

        /// <summary>
        /// Tries to extracts the name from a NameSyntax node.
        /// </summary>
        private static string? ExtractName(NameSyntax? name) {
            return name switch {
                SimpleNameSyntax ins => ins.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                AliasQualifiedNameSyntax aqns => aqns.Name.Identifier.Text,
                _ => name?.ToString()
            };
        }

        private static ITypeSymbol? GetModelParts(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // "attribute.Parent" is "AttributeListSyntax"
            // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
            if (attributeSyntax.Parent?.Parent is not InterfaceDeclarationSyntax interfaceDeclaration)
                return null;

            // This is now the actual Symbol and not the node (as seen in the Syntax Visualiser)
            var type = context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) as ITypeSymbol;

            Debug.WriteLine($"+++ {type} +++");

            return type is null || !IsFromCorrectLib(type) ? null : type;
        }

        private static bool IsFromCorrectLib(ISymbol type) {
            return type.GetAttributes()
                       .Any(a => IsLibAttributeClass(a.AttributeClass, GeneratorResources.ModelInterafaceAttributeName));
        }

        private static bool IsLibAttributeClass(INamedTypeSymbol? attributeClass, string attributeName) {
            return attributeClass?.Name == attributeName && attributeClass.ContainingNamespace is {
                Name: AttributesLibName,
                ContainingNamespace.IsGlobalNamespace: true
            };
        }

        private static void GenerateModel(SourceProductionContext context, 
            (ImmutableArray<ITypeSymbol?> elements, IAssemblySymbol assembly) providerData) {
            if (providerData.elements.IsDefaultOrEmpty)
                return;

            foreach (var element in providerData.elements) {
                if (element == null)
                    continue;

                var ns = element.ContainingNamespace.IsGlobalNamespace
                          ? null
                          : element.ContainingNamespace.ToString();
                var name = element.Name;
                var className = name.Substring(1);
                var inheritance = GetInheritance(element);

                var members = element.GetMembers();
                var (variables, methodes, events) = GetClassMembers(members);


                var code = @$"// <auto-generated />

{(ns is null ? null : $@"namespace {ns} {{")}
   public partial class {className} : {(string.IsNullOrWhiteSpace(inheritance) ? null : inheritance + ",")} {name} {{

        {String.Join("\n\t", variables)}

        {String.Join("\n\t", methodes)}

        {String.Join("\n\t", events)}
      }}
{(ns is null ? null : @"}
")}";
                ;

                context.AddSource($"{className}.g.cs", code);
            }

            
            ModelBuilder.CreateModel(providerData.elements);
        }

        private static void GetMetadata(IAssemblySymbol assembly) {
            if (assembly == null)
                return;

            foreach (var attribute in assembly.GetAttributes()) {
                if (attribute.AttributeClass?.Name == )
            }
        }

        private static string GetInheritance(ITypeSymbol element) {
            var interfaces = element.Interfaces;
            List<string> inheritance = [];
            foreach (var interfaceSymbol in interfaces) {
                var interfaceAttributes = interfaceSymbol.GetAttributes();
                if (interfaceAttributes.Any(a => IsLibAttributeClass(a.AttributeClass, GeneratorResources.ModelInterafaceAttributeName))) {
                    inheritance.Add(interfaceSymbol.Name.Substring(1));
                }
            }

            return String.Join(",", inheritance);
        }

        private static (List<string> variables, List<string> methodes, List<string> events) GetClassMembers(ImmutableArray<ISymbol> members) {
            List<string> variables = [];
            List<string> methodes = [];
            List<string> events = [];

            string visibility = "";
            string type = "";
            string memberName = "";

            foreach (var member in members) {
                switch (member) {
                    case IPropertySymbol property:
                        visibility = GetAccessibility(property.DeclaredAccessibility);
                        type = property.Type.ToDisplayString();
                        memberName = property.Name;

                        variables.Add($"private {type} _{memberName};");
                        // TODO has to check accessor with property.GetMethod; property.SetMethod;
                        methodes.Add($"{visibility} {type} {memberName} {{ get {{ return this._{memberName}; }} }}");
                        break;

                    case IMethodSymbol method when method.MethodKind == MethodKind.Ordinary:
                        visibility = GetAccessibility(method.DeclaredAccessibility);
                        type = method.ReturnType.ToDisplayString();
                        memberName = method.Name;

                        methodes.Add($"{visibility} {type} {memberName} {{ }}");
                        break;

                    case IEventSymbol eventMember:
                        visibility = GetAccessibility(eventMember.DeclaredAccessibility);
                        type = eventMember.Type.ToDisplayString();
                        memberName = eventMember.Name;

                        events.Add($"{visibility} event {type} {memberName};");
                        break;

                    // Skip accessors (get/set/add/remove)
                    default: continue;
                }
            }

                return (variables, methodes, events);
        }

        private static string GetAccessibility(Accessibility accessibility) {
            return accessibility == Accessibility.NotApplicable ? "" : accessibility.ToString().ToLower();
        }
    }
}